#!/usr/bin/env python3
"""
MCP server wrapper that intercepts and logs all stdio communication.
"""

import sys
import asyncio
import json
from datetime import datetime

LOG_FILE = "/Users/luka/src/cc/mcp-second-brain/protocol_intercept.log"

def log_message(direction: str, data: str):
    """Log a message with timestamp and direction."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
    with open(LOG_FILE, "a") as f:
        f.write(f"[{timestamp}] {direction}: {repr(data)}\n")
        # Try to parse as JSON for readability
        try:
            if data.strip():
                parsed = json.loads(data.strip())
                formatted = json.dumps(parsed, indent=2)
                f.write(f"[{timestamp}] {direction}_PARSED:\n{formatted}\n")
        except:
            pass
        f.write("-" * 80 + "\n")
        f.flush()

async def pipe_with_logging(reader, writer, direction: str):
    """Pipe data from reader to writer, logging everything."""
    try:
        while True:
            line = await reader.readline()
            if not line:
                log_message(direction, "EOF")
                break
            
            # Decode and log
            text = line.decode('utf-8', errors='replace')
            log_message(direction, text.rstrip())
            
            # Forward to destination
            writer.write(line)
            await writer.drain()
    except asyncio.CancelledError:
        log_message(direction, "CANCELLED")
        raise
    except Exception as e:
        log_message(direction, f"ERROR: {type(e).__name__}: {e}")
        raise

async def main():
    """Run the interceptor."""
    # Clear previous log
    with open(LOG_FILE, "w") as f:
        f.write(f"=== INTERCEPTOR STARTED AT {datetime.now()} ===\n")
    
    log_message("SYSTEM", "Starting MCP server subprocess")
    
    # Start the actual MCP server as subprocess
    proc = await asyncio.create_subprocess_exec(
        sys.executable, "-m", "mcp_second_brain.server",
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    
    log_message("SYSTEM", f"Server PID: {proc.pid}")
    
    # Set up stdin/stdout redirection using simple protocol
    stdin_reader = asyncio.StreamReader()
    stdin_protocol = asyncio.StreamReaderProtocol(stdin_reader)
    await asyncio.get_event_loop().connect_read_pipe(lambda: stdin_protocol, sys.stdin.buffer)
    
    # For stdout, we need to create a custom protocol
    class StdoutProtocol(asyncio.Protocol):
        def __init__(self):
            self.transport = None
            
        def connection_made(self, transport):
            self.transport = transport
            
        def write(self, data):
            if self.transport:
                self.transport.write(data)
                
        async def drain(self):
            pass  # No backpressure for stdout
    
    stdout_protocol = StdoutProtocol()
    stdout_transport, _ = await asyncio.get_event_loop().connect_write_pipe(
        lambda: stdout_protocol,
        sys.stdout.buffer
    )
    stdout_writer = stdout_protocol
    
    # Create tasks for bidirectional piping
    tasks = [
        asyncio.create_task(pipe_with_logging(stdin_reader, proc.stdin, "STDIN>>>")),
        asyncio.create_task(pipe_with_logging(proc.stdout, stdout_writer, "<<<STDOUT")),
    ]
    
    # Also log stderr
    async def log_stderr():
        async for line in proc.stderr:
            log_message("STDERR", line.decode('utf-8', errors='replace').rstrip())
    
    tasks.append(asyncio.create_task(log_stderr()))
    
    # Wait for completion
    try:
        await asyncio.gather(*tasks)
    except Exception as e:
        log_message("SYSTEM", f"ERROR: {type(e).__name__}: {e}")
    finally:
        exit_code = proc.returncode
        log_message("SYSTEM", f"Process exit code: {exit_code}")
        if exit_code is None:
            proc.terminate()
            await proc.wait()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass