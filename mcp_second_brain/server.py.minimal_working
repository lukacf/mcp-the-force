#!/usr/bin/env python3
"""Minimal MCP server for testing cancellation behavior."""

import asyncio
import logging
import sys

# Apply patches BEFORE importing FastMCP
from . import patch_cancellation_handler  # noqa: F401  # Fix for double response on cancellation

from fastmcp import FastMCP

# Set up basic logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stderr),
        logging.FileHandler("/Users/luka/src/cc/mcp-second-brain/mcp_cancellation_debug.log", mode='a')
    ]
)
logger = logging.getLogger(__name__)

# Initialize FastMCP server
mcp = FastMCP("minimal-test-server")

@mcp.tool()
async def fast_tool(message: str) -> str:
    """A fast tool that completes immediately."""
    logger.info(f"fast_tool called with: {message}")
    return f"Fast response: {message}"

@mcp.tool()
async def slow_tool(message: str, duration: int = 120) -> str:
    """A slow tool that takes time to complete."""
    logger.info(f"slow_tool called with: {message}, duration: {duration}s")
    try:
        # Simulate long-running operation
        for i in range(duration):
            await asyncio.sleep(1)
            if i % 10 == 0:
                logger.info(f"slow_tool progress: {i}/{duration}s")
        logger.info("slow_tool completed successfully")
        return f"Slow response after {duration}s: {message}"
    except asyncio.CancelledError:
        logger.info("slow_tool was cancelled")
        raise  # Re-raise to propagate cancellation

def main():
    """Run the minimal MCP server."""
    logger.info("Starting minimal MCP server...")
    
    # Handle termination
    import signal
    def handle_term(signum, frame):
        logger.info(f"Received signal {signum}")
        sys.exit(0)
    
    signal.signal(signal.SIGTERM, handle_term)
    signal.signal(signal.SIGINT, handle_term)
    
    try:
        mcp.run()  # Will use stdio transport by default
        logger.info("MCP server exited normally")
    except KeyboardInterrupt:
        logger.info("Server interrupted by user")
    except (EOFError, BrokenPipeError) as e:
        logger.info(f"Client disconnected: {type(e).__name__}")
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
        raise

if __name__ == "__main__":
    main()